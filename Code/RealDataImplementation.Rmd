---
title: "RealDataImplementation"
output: pdf_document
date: "2025-07-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#library(terra)
library(sf)
library(tidyverse)
library(dplyr)
#library(mapview)
#library(sp)
#library(usmap)
#library(raster)
library(igraph)
#library(GGally)
#library(ggnet)
#library(geosphere)
#library(lubridate)
#library(gganimate)
#library(gifski)
library(png)
#library(legendry)
library(RColorBrewer)
#library(ggiraph)
#library(plotly)
#library(network)
#library(intergraph)
#library(ergm)
library(gridExtra)
library(ggpubr)
library(ecr)
library(nsga2R)

#library(kableExtra)
#library(ggside)
#library(grid)
#library(ggnewscale)
#library(patchwork)
```


## Loading time series of covid data.

```{r}
##Loading city limits data 
hwpath = "C:/Users/gauph/Documents/StatisticsMS_PhD/Wastewater-Surveillance-OSU/RScripts/OSDLDataExtract/data.gdb"
#rgdal::ogrListLayers(hwpath)
ct <- st_read(hwpath, layer = "City_Limits__2016_")
ct <- st_transform(ct, 2994)

sunriver <- st_read("C:/Users/gauph/Documents/StatisticsMS_PhD/Wastewater-Surveillance-OSU/Sunbelt23/Data/SunriverShapefile/Sunriver.shp")
sunriver<-  st_transform(sunriver, crs = 2994)
sunriver <- rename(sunriver, city_name = id)
sunriver$city_name[1] <- "Sunriver"
sunriver <- rename(sunriver, shape = geometry)
sunriver <- st_cast(sunriver, "MULTIPOLYGON")

## adding rock creek shapefile
Rockcreek <- st_read("C:/Users/gauph/Documents/StatisticsMS_PhD/Wastewater-Surveillance-OSU/Sunbelt23/Data/RockcreekShapefile/Rockcreek.shp")
Rockcreek <-  st_transform(Rockcreek, crs = 2994)
Rockcreek <- rename(Rockcreek, city_name = id)
Rockcreek$city_name[1] <- "Rock Creek"
Rockcreek <- rename(Rockcreek, shape = geometry)
Rockcreek <- st_cast(Rockcreek, "MULTIPOLYGON")

ct <- bind_rows(ct, sunriver,Rockcreek)
## reading the 2024 city limits using terra library
#citylim_path <- "C:/Users/gauph/Documents/StatisticsMS_PhD/Wastewater-Surveillance-OSU/RScripts/City_Limits_2022/City_Limits.shp"
#ct <- sf::st_read(citylim_path)

## Loading covid levels data
WD <- paste0(fs::path_home(), "/Box/Preliminary Results Coronavirus Sewer Surveillance/ddPCR results/Covid/R output data/7.11.25/Combined_all_data_2025-07-11.xlsx")
dat <- readxl::read_excel(WD,sheet = "COVID", guess_max = 10000)
## cities present in ct and wastewater data
ct_sbst <- ct$city_name[ct$city_name %in% unique(dat$Location)]

## Which locations are not there in the ct database
no_ct_dat <-  unique(dat$Location)[!(unique(dat$Location) %in% ct_sbst)]
no_ct_dat

df <- dat[dat$Location %in% ct_sbst, ]


df_OHA <- df[df$Study == "OHA",]
#df_OHA <- df_OHA[df_OHA$QualCall == "Negative",]

df_OHA <- df_OHA[!(is.na(df_OHA$Location)),]

df_OHA <- df_OHA[df_OHA$Location %in% ct_sbst,]

df_OHA <- df_OHA[df_OHA$CopiesPerul > 0 , ]

df_OHA <- df_OHA[!is.na(df_OHA$SampleType),]

df_OHA <- df_OHA[!(is.na(df_OHA$County)),]

gbg <- data.frame(table(df_OHA$Location, df_OHA$County))
gbg <- gbg[gbg$Freq > 0,]

## Removing gilliam county
df_OHA <- df_OHA[!(df_OHA$County == "Gilliam County"),]

#gbg <- df_OHA[df_OHA$Location == "Corvallis",]
## remove columns that we wont use

df_OHA <- df_OHA %>%
  dplyr::mutate(Date = lubridate::mdy(Date)) %>%
  dplyr::mutate(year = lubridate::year(Date), 
                month = lubridate::month(Date), 
                day = lubridate::day(Date))

df_OHA <- df_OHA %>%
  dplyr::mutate(Month_Yr = format(as.Date(Date),"%Y-%m")) %>% 
  dplyr::mutate(weekno = as.numeric(Date - min(Date, na.rm = TRUE)),
         weekno = (weekno %/% 7) + 1) %>%
  group_by(weekno) %>% 
  arrange(desc(CopiesPerul)) %>%
  dplyr::mutate(
    maxByVal = if_else(row_number() == 1, "1", "0")
  ) %>%
  arrange(weekno)%>%
  ungroup()

df_OHA <- df_OHA %>% 
  dplyr::select(c(CopiesPerul,Date,Location,MasterID,logCopies,County,weekno,Month_Yr,
           maxByVal,year,month,day )) %>%
  distinct()


aggr <- df_OHA %>%
  group_by(weekno, Location) %>%
  filter(CopiesPerul == max(CopiesPerul, na.rm = TRUE)) %>%
  dplyr::mutate(yy = substr(year, 3,4))

saveRDS(aggr, "aggr_7_11.rds")

# colors <-  c("cornflowerblue", "coral2","chocolate3", "chartreuse4","brown4","blue4",
#              "darkorchid", "orangered","gold1","cyan2","slateblue3","salmon4",
#              "darkolivegreen1", "aquamarine","firebrick2", "maroon2","dodgerblue",
#              "sienna3")
# colors <- c(
#   "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2",
#   "#1AFF1A", "#bcbd22", "#17becf", "#aec7e8", "#ffbb78", "#98df8a", "#ff9896",
#   "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5", "#393b79",
#   "#637939", "#8c6d31", "#843c39", "#b5cf6b", "#cedb9c", "#8ca252", "#6b6ecf")
# colors_cb <- c(
#   "#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00",
#   "#CC79A7", "#999999", "#332288", "#88CCEE", "#44AA99", "#117733", "#999933",
#   "#DDCC77", "#661100", "#CC6677", "#AA4466", "#882255", "#AA4499", "#777777",
#   "#5D3A9B", "#E66100", "#40B0A6", "#E1BE6A", "#1AFF1A", "#4B0092", "#FF6E3A"
# )
# 
# 
# p <- ggplot()+
#   geom_point(data = subset(aggr, CopiesPerul < 300) , 
#              aes(x = weekno, y = CopiesPerul, group = Location), 
#              color = "grey37",alpha =0.2)+
#   theme_minimal() +
#   theme(axis.line = element_line(colour = "black"),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         panel.border = element_blank(),
#         panel.background = element_blank(),
#         axis.text.x = element_text(angle = 90, hjust = 1),
#         legend.position = "none") + 
#   labs(x = "Week number stating from September 2nd 2020", y = "SARS-COV2 concentration in Copies per uL")+
#   geom_point(data = subset(aggr, maxByVal == "1" & CopiesPerul < 300), 
#              aes(x = weekno, y = CopiesPerul,color = County, group = Location))+
#   scale_color_manual(values = colors)

#ggplotly(p)
```

## Find the total number missing values per week.

```{r}
#length(unique(aggr$Location))
#unique(aggr$Location)
unique_count <- as.data.frame(table(aggr$weekno))
unique_loc <- as.data.frame(table(aggr$Location ))
ggplot(unique_count)+ geom_line(aes(x = as.numeric(Var1), y = Freq ))
```

## Decide on the week with the least number of missing data. Maybe 10 such weeks.

```{r}
## looks like week number 102 has the maximum number of locations? 36 locations out of 45. 
aggr_102 <- aggr %>% filter(weekno == 102) %>% ungroup()

```

## Loading the network.
```{r}
## Reading the shortest path graph created in MapNetworkCode.Rmd
directGrph <- readRDS("ShortestPathGrph5.rds")

```

## Subsetting network with the selected week.

```{r}
city_cntr <- ct %>% 
  st_as_sf() %>% 
  st_centroid() %>% 
  st_cast("POINT") %>% 
  st_transform(4326) %>% 
  st_coordinates()

O_attr <- as.data.frame(cbind(as.data.frame(vertex_attr(directGrph)), city_cntr))
saveRDS(O_attr,"O_attr.rds")
plot.igraph(directGrph, vertex.label = NA, vertex.size = 1,
            vertex.color = V(directGrph)$included, 
            vertex.frame.color = V(directGrph)$included, 
            edge.color = "darkgrey", edge.width = 1, 
            layout = city_cntr)


attr <- O_attr[O_attr$name %in% aggr_102$Location,]
attr <- left_join(attr, aggr_102 %>% dplyr::select(Location, CopiesPerul), by=join_by(name == Location))

G_subGrph <- induced_subgraph(directGrph, vids = attr$name)
plot.igraph(G_subGrph, vertex.label = NA, vertex.size = 1,
            vertex.color = V(G_subGrph)$included, 
            vertex.frame.color = V(G_subGrph)$included, 
            edge.color = "darkgrey", edge.width = 1, 
            layout = as.matrix(attr[,3:4]))

```


## Run method on the full network with missing data imputation.

```{r}
G_FullGrph <- delete_vertices(directGrph, V(directGrph)[included == "grey37"])
fg_attr <- O_attr[O_attr$included == "orangered3",]
fg_attr <- fg_attr[fg_attr$name %in% unique(aggr$Location), ]
plot.igraph(G_FullGrph, vertex.label = NA, vertex.size = 1,
            vertex.color = V(G_FullGrph)$included, 
            vertex.frame.color = V(G_FullGrph)$included, 
            edge.color = "darkgrey", edge.width = 1, 
            layout = city_cntr[V(directGrph)[included != "grey37"], ])
G_FullGrph <- induced_subgraph(G_FullGrph,vids = fg_attr$name)
plot.igraph(G_FullGrph, vertex.label = NA, vertex.size = 1,
            vertex.color = V(G_FullGrph)$included, 
            vertex.frame.color = V(G_FullGrph)$included, 
            edge.color = "darkgrey", edge.width = 1, 
            layout = city_cntr[O_attr$name %in% fg_attr$name, ])
```

```{r}
df <- as.data.frame(vertex_attr(G_FullGrph))

## joining the data and creating na's for where there is no data
fg_attr <- left_join(fg_attr,aggr_102 %>% 
                       dplyr::select(CopiesPerul, Location), 
                     by = join_by(name == Location))

G_FullGrph <- set_vertex_attr(G_FullGrph,name = "CopiesPerul", value = fg_attr$CopiesPerul )
G_FullGrph <- set_vertex_attr(G_FullGrph, name = "X", value = as.matrix(fg_attr$X ))
G_FullGrph <- set_vertex_attr(G_FullGrph, name = "Y", value = as.matrix(fg_attr$Y ))
#G <- readRDS("G_FullGrph.rds")
saveRDS(G_FullGrph, "G_FullGrph5.rds")
```


## Assessing output from the method

```{r, fig.height=9,fig.width=14}
## Alpha: learning rate
## Lambda: penalty param
## k : number of clusters
## 1. BIC (Have to use for smaller networks)
## 2. CV
## Number of folds
## 3. Consensus based methods

## Aggregate data from 7/11/25
aggr <- readRDS(paste0(getwd(),"/aggr_7_11.rds"))
unique_count <- as.data.frame(table(aggr$weekno))

## reading full graph
## Read full graph
G_FullGrph <- readRDS(paste0(getwd(),"/G_FullGrph5.rds"))

## geolocations of cities in oregon. Includes column for included or not included wastewater locations
O_attr <- readRDS(paste0(getwd(),"/O_attr.rds"))
G_nocov <- G_FullGrph
fg_attr <- O_attr[O_attr$included == "orangered3",]
fg_attr <- fg_attr[fg_attr$name %in% unique(aggr$Location), ]
G_nocov <- set_vertex_attr(G_nocov, name = "X", value = as.matrix(fg_attr$X ))
G_nocov <- set_vertex_attr(G_nocov, name = "Y", value = as.matrix(fg_attr$Y ))
G_FullGrph <- G_nocov
degV <- igraph::degree(G_FullGrph)
degV <- data.frame(cbind(City = names(degV), Value = as.numeric(degV)))
degV$Value <- as.numeric(degV$Value)


test_nc <- c(2,3,4,5,6) ## Can change
N <- vcount(G_FullGrph)
thresh  <- 0.00005
nitermax <- 30000
dir <- "undirected"
alphaLL <- 0.001
alphaOpt <- c(0.00001, 0.0001)
test = FALSE
missing <- NULL
alphaLin <- 0.001
penaltyOpt <- c("Ridge","LASSO","ElasticNet")
seed <- 5
lambdaOpt <- c(0.00001, 0.0001, 0.001)
covInitOpt <- c("Nmean")

paramGrid <-  matrix(0, nrow =0, ncol = 4)#expand_grid(test_nc, alphaOpt, covInitOpt, penaltyOpt, lambdaOpt)
for(nc in test_nc){
  for(alpha in alphaOpt){
    for(covInit in covInitOpt){
      for(pen in penaltyOpt){
        for(lambda in lambdaOpt){
          paramGrid <- rbind(paramGrid, c(alpha,covInit,pen,lambda))
        }
      }
    }
  }
}
colnames(paramGrid) <-c("alpha","covInit","penalty","lambda")
## make a list of neighbours of each node
allneigh <- list()
for(node in V(G_FullGrph)){
  allneigh[[node]] <- lapply(names(neighbors(G_FullGrph, node)), trimws)
}
degV$neigh <- allneigh
Nnodes <- vcount(G_FullGrph)
Nedges <- ecount(G_FullGrph)
boxFolder <- "C:/Users/gauph/Box/SimulationOutput/CoDAOP/RealCOVIDDataW_metrics_AllWeeks/"
files <- list.files(boxFolder)
NumWeeks <- 1:253
finOP <- matrix(0, nrow = 0, ncol = 16 )
numCom <- readRDS(paste0(boxFolder,"realCOVID_NumberOfCommunitiesLogcopies","102",".rds"))
names <- rownames(numCom)
imputedVals <- matrix(0, ncol = 5, nrow = 0)
Weekmetrics <- matrix(0,nrow=0, ncol = 32)

## get the first date of the work week


for(i in NumWeeks){
  df <- readRDS(paste0(boxFolder,"realCOVID_DataOPLogcopies", i,".rds"))
  finOP_i <- as.data.frame(cbind(df, test_nc, i)) 
  finOP_i[,c(1:8, 11:14)] <- as.data.frame(apply(finOP_i[,c(1:8, 11:14)],2,as.numeric))
  #finOP_i <- finOP_i %>% 
  #  dplyr::mutate(BICnet = BIC(LLTot, test_nc, Nedges, Nnodes), 
  #                BICReg = BICReg(LLTot, test_nc, Nedges, Nnodes))
  finOP <- rbind(finOP, finOP_i)
  
  ## reading imputed values. Mean, Stddev, minBIcnet and minBIcReg
  imputedV <- as.data.frame(readRDS(paste0(boxFolder,"ImputedValuesLogcopies",i,".rds")))
  mean_i <- apply(imputedV, 1, mean)
  median_i <- apply(imputedV, 1, median)
  sd_i <- apply(imputedV,1,sd)
  minBICnet_i <- imputedV[,which.min(finOP_i$BICnet)]
  minBICreg_i <- imputedV[,which.min(finOP_i$BICReg)]
  imputedVals <- rbind(imputedVals, cbind(mean_i, median_i, sd_i, i,names))
  
  ## reading metrics values 
  Weekmetrics <- rbind(Weekmetrics , cbind(readRDS(paste0(boxFolder,"MetricsPO",i,".rds")), i = i))
  #Weekmetrics <- as.data.frame(cbind( Weekmetrics, paramGrid ))
}

Weekmetrics <- as.data.frame(Weekmetrics)
## Dataframe of imputed values
imputedVals <- as.data.frame(imputedVals)
imputedVals[,1:4] <- apply(imputedVals[,1:4], 2, as.numeric)
imputedVals$Missing <- !(imputedVals$sd_i == 0)

```

```{r}
## for each locations for each week, find the number of neighbours that are missing 
MissingNeighPerWeek <- left_join(imputedVals %>% select(names,Missing,i), degV %>% select(City, neigh, Value),join_by(names == City) )

MissingNeighPerWeek <- MissingNeighPerWeek %>% 
  group_by(i) %>%
  mutate(neighbors_missing_count = map2_dbl(
    names, neigh,
    ~ {
      # Get the neighbors for the current row
      current_neighbors <- .y
      
      # Filter the current week's data for these neighbors
      neighbor_data <- filter(cur_data(), names %in% current_neighbors)
      
      # Count how many neighbors have Missing == TRUE
      sum(neighbor_data$Missing == TRUE, na.rm = TRUE)
    }
  )) %>%
  ungroup()


## Finding the number of missing per location
MissingByLoc <- imputedVals %>% 
  group_by(names) %>% 
  summarise(across(Missing, sum)) %>%
  arrange(Missing) %>%
  ungroup()

MissingByWeek <- imputedVals %>%
  group_by(i) %>%
  summarise(across(Missing, sum)) %>%
  ungroup()

Weeklyavg <- imputedVals %>% 
  filter(Missing == FALSE) %>%
  #mutate(across(-Missing, ~ ifelse(Missing == TRUE, 0, .)))
  group_by(i) %>% 
  summarise(across(where(is.numeric), mean, na.rm = T)) %>%
  pivot_longer(!i) 

Weeklymax <- imputedVals %>% 
  filter(Missing == FALSE) %>%
  #mutate(across(-Missing, ~ ifelse(Missing == TRUE, 0, .)))
  group_by(i) %>% 
  summarise(across(where(is.numeric), max, na.rm = T)) %>%
  pivot_longer(!i) 

Weeklymin <- imputedVals %>% 
  filter(Missing == FALSE) %>%
  #mutate(across(-Missing, ~ ifelse(Missing == TRUE, 0, .)))
  group_by(i) %>% 
  summarise(across(where(is.numeric), min, na.rm = T)) %>%
  pivot_longer(!i) 

```


```{r}
## finding the pareto front for the week using the conductance and variance metrics
Weekmetrics[,c(1:26) ] <- apply( Weekmetrics[,c(1:26)] , 2, as.numeric)
#Weekmetrics$BICnet <- finOP$BICnet
#Weekmetrics$BICreg <- finOP$BICReg
df <- Weekmetrics %>%
group_by(i) %>%
  group_split() 
fr <- c()
for(i in 1:length(df)){
  X <-  df[[i]] %>%
    select(WeightedMeanConductanceW, WeightedDispersionScoreW ) %>% 
    t()
fronts <- doNondominatedSorting(X)

fr <- c(fr, fronts$ranks)

}
FrontTotal <- bind_rows(df) 
FrontTotal$fronts <- fr

FirstFront <- FrontTotal %>% filter(fronts %in% c(1)) %>% arrange(as.numeric(i))
FirstFront$i <- as.numeric(FirstFront$i)
saveRDS(FirstFront, "FirstFront_COVID.rds")
#FirstFront_covid <- readRDS("FirstFront_COVID.rds")
  ## plotting the conductance vs avg dispersion linking by pareto front
FrontTotal %>% filter(i %in% 100: 104)%>%
          ggplot +
          geom_point(aes(x = WeightedMeanConductanceW, y =WeightedDispersionScoreW ,color= as.factor(nc))) +
          geom_line(aes(x = WeightedMeanConductanceW, y =WeightedDispersionScoreW , group = fronts, color= as.factor(alpha)))+
  facet_wrap(~i)+
          theme(legend.position = "bottom", panel.background = element_blank())


#FirstTwoFronts <- Weekmetrics %>% filter(front %in% c(1))
```

```{r}
FrontTotal %>% 
  filter(i == "102") %>% 
  ggplot() +
  geom_point(aes(x = WeightedMeanConductanceW, y = BICnet, color = as.factor(nc)))+
  facet_wrap(~penalty)
```


```{r}
##Plotting for BIC values
## plotting the values of the covariate 
Weeklyavg %>% 
  filter(name != "sd_i") %>%
  ggplot() +
  geom_line(aes(x = i, y = value), color= "blue1")+
  theme(legend.position = "bottom", panel.background = element_blank())
colors <-  c("blue4","cornflowerblue", "coral2","cyan2", "chartreuse4","orangered","gold1","chocolate3")

## Converting missing column into category
imputedVals$Missing <- ifelse(imputedVals$Missing == TRUE,"Missing","Available")

## plotting top 8 cities
top8 <- imputedVals %>% 
  filter(names %in% head(MissingByLoc$names, 8)) %>%
  pivot_longer(!c(i, names, Missing)) %>% 
  filter(name != "sd_i")

for(city in unique(top8$names)){
  p1 <- top8 %>% 
    filter(names == city, !(name %in% c("median_i","mean_i"))) %>%
    ggplot() +
    geom_line(aes(x = i, y = value, color = name, group = name), alpha  = 0.8) +
    scale_color_manual(name = "",values = colors) +
    geom_point(aes(x = i, y = value, color = Missing, group = name), size = 0.5) +
    geom_vline(aes(xintercept = 102), linetype = 2, color = "gray60") + 
    ggtitle(paste0("Top8: ", city, " degree: ",degV$Value[degV$City == city] )) +
    theme(legend.position = "bottom", panel.background = element_blank())
  
  p2 <- MissingByWeek %>%
    ggplot()+
    geom_line(aes(x = i, y = Missing))+
    theme(legend.position = "bottom", panel.background = element_blank())
  print(p1 / p2 + plot_layout(heights = c(2, 1)))
  
}
## plotting bicnet and bic reg with the state avg
for(city in unique(top8$names)){
  neighVals <-  imputedVals %>%
    filter(names %in% degV[which(degV$City == city),]$neigh[[1]]) %>%
    group_by(i) %>%
    summarise(across(where(is.numeric), mean, na.rm = T)) %>%
    ungroup()%>%
    pivot_longer(!c(i)) %>% 
    filter(!(name %in% c("sd_i","mean_i","median_i")))
  
  
  p1 <- top8 %>% 
    filter(names == city, name %in% c("minBICnet_i") ) %>%
    ggplot() +
    geom_line(aes(x = i, y = value, color = name, group = name), alpha  = 0.5) +
    geom_point(aes(x = i, y = value, color = Missing, group = name), size = 0.5) +
    geom_line(data = Weeklyavg %>% filter(name == "minBICnet_i"), aes(x = i, y = value , color ="Weekly Avg"), alpha  = 0.5)+
    geom_line(data = neighVals %>% filter(name == "minBICnet_i"), aes(x = i, y = value , color ="Neighbour net Avg"), alpha  = 0.5)+
    geom_point(data = MissingNeighPerWeek %>% filter(names == city, Missing == TRUE), aes(x = i, y = neighbors_missing_count, color = "Number Missing" ), size =0.8)+
    geom_vline(aes(xintercept = 102), linetype = 2, color = "gray60")+ 
    ggtitle("Min BIC for network") +
    scale_color_manual(
      name = "",
      values = c("Weekly Avg" = "gold1", "Neighbour net Avg" = "chocolate4","Number Missing" = "brown","minBICnet_i" = "chartreuse4", "Missing" = "blue4", "Available" = "cornflowerblue"),
      breaks = c("Weekly Avg", "Neighbour net Avg", "Number Missing","minBICnet_i", "Missing", "Available"))+
    #scale_color_manual(values = c("blue4","cornflowerblue","orangered", "chartreuse4", "coral2")) +
    theme(legend.position = "bottom", panel.background = element_blank())
  
  p2 <- top8 %>% 
    filter(names == city, name %in% c("minBICreg_i") ) %>%
    ggplot() +
    geom_line(aes(x = i, y = value, color = name, group = name), alpha  = 0.5) +
    geom_point(aes(x = i, y = value, color = Missing, group = name), size = 0.5) +
    geom_line(data = Weeklyavg %>% filter(name == "minBICreg_i"), aes(x = i, y = value , color ="Weekly Avg"), alpha  = 0.5)+
    geom_line(data = neighVals %>% filter(name == "minBICreg_i"), aes(x = i, y = value , color ="Neighbour reg Avg"), alpha  = 0.5)+
    geom_point(data = MissingNeighPerWeek %>% filter(names == city, Missing == TRUE), aes(x = i, y = neighbors_missing_count, color = "Number Missing" ), size =0.8)+
    geom_vline(aes(xintercept = 102), linetype = 2, color = "gray60")+ 
    ggtitle("Min BIC for network") +
    scale_color_manual(
      name = "",
      values = c("Weekly Avg" = "gold1","Neighbour reg Avg" = "chocolate3", "Number Missing" = "brown","minBICreg_i" = "chartreuse4", "Missing" = "blue4", "Available" = "cornflowerblue"),
      breaks = c("Weekly Avg", "Neighbour reg Avg", "Number Missing","minBICreg_i", "Missing", "Available"))+
    #scale_color_manual(values = c("blue4","cornflowerblue","orangered", "chartreuse4", "coral2")) +
    theme(legend.position = "bottom", panel.background = element_blank())
  
  print(p1 / p2 + 
          plot_layout(heights = c(1, 1))+
          plot_annotation(
            title = paste0("Bottom 8 vs State vs neighbour avg: ", city, " degree: ",degV$Value[degV$City == city] )
            #subtitle = 'These 3 plots will reveal yet-untold secrets about our beloved data-set',
            #caption = 'Disclaimer: None of these plots are insightful'
          ))
}
## plotting bottom 8 cities
bot8 <- imputedVals %>% 
  filter(names %in% tail(MissingByLoc$names, 8)) %>%
  pivot_longer(!c(i, names, Missing)) %>% 
  filter(name != "sd_i")

for(city in unique(bot8$names)){
  p1 <- bot8 %>% 
    filter(names == city, !(name %in% c("median_i","mean_i"))) %>%
    ggplot() +
    geom_line(aes(x = i, y = value, color = name, group = name), alpha  = 0.8) +
    scale_color_manual(name = "",values = colors) +
    geom_point(aes(x = i, y = value, color = Missing, group = name), size = 0.5) +
    geom_vline(aes(xintercept = 102), linetype = 2, color = "gray60")+ 
    ggtitle(paste0( "Bottom 8: ",city, " degree: ",degV$Value[degV$City == city])) +
    theme(legend.position = "bottom", panel.background = element_blank())
  
  p2 <- MissingByWeek %>%
    ggplot() +
    geom_line(aes(x = i, y = Missing))+ 
    theme(legend.position = "bottom", panel.background = element_blank())
  
  print(p1 / p2 + plot_layout(heights = c(2, 1)))
  
}
## plotting bicnet and bic reg with the state avg

for(city in unique(bot8$names)){
  neighVals <-  imputedVals %>%
    filter(names %in% degV[which(degV$City == city),]$neigh[[1]]) %>%
    group_by(i) %>%
    summarise(across(where(is.numeric), mean, na.rm = T)) %>%
    ungroup()%>%
    pivot_longer(!c(i)) %>% 
    filter(!(name %in% c("sd_i","mean_i","median_i")))
  
  
  p1 <- bot8 %>% 
    filter(names == city, name %in% c("minBICnet_i") ) %>%
    ggplot() +
    geom_line(aes(x = i, y = value, color = name, group = name), alpha  = 0.5) +
    geom_point(aes(x = i, y = value, color = Missing, group = name), size = 0.5) +
    geom_line(data = Weeklyavg %>% filter(name == "minBICnet_i"), aes(x = i, y = value , color ="Weekly Avg"), alpha  = 0.5)+
    geom_line(data = neighVals %>% filter(name == "minBICnet_i"), aes(x = i, y = value , color ="Neighbour net Avg"), alpha  = 0.5)+
    geom_point(data = MissingNeighPerWeek %>% filter(names == city, Missing == TRUE), aes(x = i, y = neighbors_missing_count, color = "Number Missing" ), size =0.8)+
    geom_vline(aes(xintercept = 102), linetype = 2, color = "gray60")+ 
    ggtitle("Min BIC for network") +
    scale_color_manual(
      name = "",
      values = c("Weekly Avg" = "gold1", "Neighbour net Avg" = "chocolate4","Number Missing" = "brown","minBICnet_i" = "chartreuse4", "Missing" = "blue4", "Available" = "cornflowerblue"),
      breaks = c("Weekly Avg", "Neighbour net Avg", "Number Missing","minBICnet_i", "Missing", "Available"))+
    #scale_color_manual(values = c("blue4","cornflowerblue","orangered", "chartreuse4", "coral2")) +
    theme(legend.position = "bottom", panel.background = element_blank())
  
  p2 <- bot8 %>% 
    filter(names == city, name %in% c("minBICreg_i") ) %>%
    ggplot() +
    geom_line(aes(x = i, y = value, color = name, group = name), alpha  = 0.5) +
    geom_point(aes(x = i, y = value, color = Missing, group = name), size = 0.5) +
    geom_line(data = Weeklyavg %>% filter(name == "minBICreg_i"), aes(x = i, y = value , color ="Weekly Avg"), alpha  = 0.5)+
    geom_line(data = neighVals %>% filter(name == "minBICreg_i"), aes(x = i, y = value , color ="Neighbour reg Avg"), alpha  = 0.5)+
    geom_point(data = MissingNeighPerWeek %>% filter(names == city, Missing == TRUE), aes(x = i, y = neighbors_missing_count, color = "Number Missing" ), size =0.8)+
    geom_vline(aes(xintercept = 102), linetype = 2, color = "gray60")+ 
    ggtitle("Min BIC for network") +
    scale_color_manual(
      name = "",
      values = c("Weekly Avg" = "gold1","Neighbour reg Avg" = "chocolate3", "Number Missing" = "brown","minBICreg_i" = "chartreuse4", "Missing" = "blue4", "Available" = "cornflowerblue"),
      breaks = c("Weekly Avg", "Neighbour reg Avg", "Number Missing","minBICreg_i", "Missing", "Available"))+
    #scale_color_manual(values = c("blue4","cornflowerblue","orangered", "chartreuse4", "coral2")) +
    theme(legend.position = "bottom", panel.background = element_blank())
  
  print(p1 / p2 + 
          plot_layout(heights = c(1, 1))+
          plot_annotation(
            title = paste0("Bottom 8 vs State vs neighbour avg: ", city, " degree: ",degV$Value[degV$City == city] )
            #subtitle = 'These 3 plots will reveal yet-untold secrets about our beloved data-set',
            #caption = 'Disclaimer: None of these plots are insightful'
          ))
}

finOPMinBIC_net <- finOP %>%
  group_by(Week) %>%
  slice_min(BICnet, n = 1)

finOPMinBIC_reg <- finOP %>%
  group_by(Week) %>%
  slice_min(BICReg, n = 1)

finOPMinMSE_reg <- finOP %>%
  group_by(Week) %>%
  slice_min(MSE, n = 1)

finOP102 <- finOP %>% filter(Week == 102)

```


```{r}

## 102 with logcopies
finOP_102 <- as.data.frame(cbind(readRDS(paste0(getwd(),"/../realCOVID_DataOPLogcopies102.rds")), c(2,3,4),102)) 
finOP_102[,c(1:8, 11:14)] <- apply(finOP_102[,c(1:8, 11:14)],2,as.numeric)
finOP_102 <- finOP_102 %>% 
  mutate(BICnet = BIC(LLTot, c(2,3,4), Nedges, Nnodes),
         BICReg = BICReg(LLTot, c(2,3,4), Nedges, Nnodes))
## reading imputed values. Mean, Stddev, minBIcnet and minBIcReg
imputedV102 <- as.data.frame(readRDS(paste0(getwd(),"/../ImputedValuesLogcopies102.rds")))
imputedV102 <- cbind(imputedV102, imputedVals %>% filter(i == 102) %>% select(Missing, minBICnet_i, minBICreg_i), degV$City)

aggr %>% group_by(weekno) %>% summarise(sdCpsperul = sd(CopiesPerul, na.rm = TRUE), sdlogCps = sd(logCopies, na.rm =TRUE))
# numCom <- readRDS(paste0(boxFolder,"realCOVID_NumberOfCommunities",i,".rds"))
# numCom_nocov <- readRDS(paste0(boxFolder,"realCOVID_NumberOfCommunitiesNoCov",i,".rds"))
# op_sim <- readRDS(paste0(boxFolder,"realCOVID_NetworkmetricsCovOutput",i,".rds"))

```

# Small NW experiments

```{r}
getwd()
smallNWop <- readRDS("../SmallNWopNsimAllGT3.rds")
op <- smallNWop[[1]]
graph_list <- smallNWop[[2]]
CovOrigList <- smallNWop[[3]]

N <- 9
Nsim <- 1
nc <- 2
alphaOpt <- c(0.00001, 0.0001, 0.001)
penaltyOpt <- c("Ridge","LASSO","ElasticNet")
lambdaOpt <- c(0.00001, 0.0001, 0.001)
covInitOpt <- c("Nmean","Nmedian","Nmode")
NWType <- c(rep("Fullconn",5),rep("TwoClust",4), rep("TwoOLClust", 5))
CovNames <- c("OneCovNoMiss","OneCovOneMiss","TwoCovNoMiss","TwoCovOneMiss",
              "TwoCovTwoMiss","OneCovNoMiss","OneCovOneMiss","TwoCovNoMiss",
              "TwoCovOneMiss","OneCovNoMiss","OneCovComMiss","TwoCovNoMissAvgCom",
              "TwoCovNoMissGrp1Com","TwoCovComMiss")
grph_idx <- c(rep(1,5), rep(2,4), rep(3,5))
covorigLst <- c(1,1,2,2,2,3,3,4,4,5,5,6,7,7)

idx <- 1

## relevant output
colnamesV <- c("i","idx","nsim","alpha","covInit","penalty","lambda","MSE","MSEMD","LogLik","GraphId","covName","BIC","ICL","Len","OI",paste0("Cov",1:9))
OP <- matrix(0, nrow =0 , ncol = length(colnamesV))
idx <- 1
for(i in 1:14){
  print(idx)
  covName <- CovNames[i]
  Grph <- graph_list[[grph_idx[i]]]
  covOrig <- CovOrigList[[covorigLst[[i]] ]]
  E <- ecount(Grph)
  for(m in 1:Nsim){
    for(alpha in alphaOpt){
      for(covInit in covInitOpt){
        for(penalty in penaltyOpt){
          for(lambda in lambdaOpt){
            OP <- rbind(OP,c(i,idx,m,alpha,covInit,penalty,lambda,op[[idx]]$MSE[1],
                             op[[idx]]$MSEMD[1],tail(op[[idx]]$Loglik[1],1),
                             grph_idx[i],covName,
                             BIC(as.numeric(tail(op[[idx]]$Loglik,1)[1]), nc, N,E),
                             ICL(as.numeric(tail(op[[idx]]$Loglik,1)[1]),op[[idx]]$Ffin,nc,N,E),
                             dim(op[[idx]]$Loglik)[1],tail(op[[idx]]$OmegaIndex,1),
                             c(op[[idx]]$Zout_cov)))
            idx <- idx +1
          }
        }
      }
    }
  }
}

OP <- as.data.frame(as.matrix(OP))
OP[,c(1:4,7:11,13:25)] <- apply(OP[,c(1:4,7:11,13:25)], 2, as.numeric)

colnames(OP) <- colnamesV

## find combinations with the minimum bic value
minBICOP <- OP %>% 
  group_by(i) %>% 
  slice_min(BIC, n = 1, with_ties = FALSE) %>%
  mutate(type = "Minbic")

## find combinations with the minimum MSE value
minMSEOP <- OP %>% 
  group_by(i) %>% 
  slice_min(MSE, n = 1, with_ties = FALSE)%>%
  mutate(type = "Minmse")

## find combinations with the max OI value
maxOIOP <- OP %>% 
  group_by(i) %>% 
  slice_max(OI, n = 1, with_ties = FALSE)%>%
  mutate(type = "MaxOI")

## find combinations with the max ICL value
maxICLOP <- OP %>% 
  group_by(i) %>% 
  slice_max(ICL, n = 1, with_ties = F)%>%
  mutate(type = "MaxICL")

combn <- rbind(minBICOP, minMSEOP,maxOIOP,maxICLOP)

## Summarise values
resultMSE <- OP %>%
  group_by(i) %>%
  summarise(
    mean_MSE = mean(MSE, na.rm = TRUE),
    sd_MSE = sd(MSE, na.rm = TRUE),
    median_MSE = median(MSE, na.rm = TRUE),
    min_MSE = min(MSE, na.rm = TRUE),
    max_MSE = max(MSE, na.rm = TRUE),
    count = n()  ) %>%
  pivot_longer(!i)

resultBIC <- OP %>%
  group_by(i) %>%
  summarise(
    mean_bic = mean(BIC, na.rm = TRUE),
    sd_BIC = sd(BIC, na.rm = TRUE),
    median_BIC = median(BIC, na.rm = TRUE),
    min_BIC = min(BIC, na.rm = TRUE),
    max_BIC = max(BIC, na.rm = TRUE),
    count = n()
  ) %>%
  pivot_longer(!i)

for(G in graph_list){
  igraph::plot.igraph(G,vertex.label = NA,vertex.size = 5,
                      edge.arrow.size= 0.1, edge.color = "grey28")
}


```


```{r}
#egoconductance example
e <- c(1,2,1,3,1,4,2,3,3,4,3,5,4,5,4,6,4,8,5,6,5,7,7,8,4,11,11,9,11,10,10,9,6,7)
e <- matrix(e, ncol =2, byrow = T)
G <- graph_from_edgelist(e,directed = F)
plot.igraph(G,vertex.size = 5,edge.arrow.size= 0.1, edge.color = "grey28")
com <- matrix(cbind(c(1,1,1,1,1,0,0,0,0,0,0), c(0,0,0,1,1,1,1,1,0,0,0), c(0,0,0,1,0,0,0,0,1,1,1)), ncol =3)
EgoSplitConductance(G, Fm = com, Hm = com, dir ="undirected", delta, N= vcount(G), nc=3)

```
