---
title: "CESNA"
output: pdf_document
date: "2024-06-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
library(igraph)
library(network)
library(intergraph)
library(ergm)
library(gridExtra)
library(RColorBrewer)
```

## Function for community detection.

```{r}


prob2logit <- function(x){
  return(log(x / (1 - x)))
}

## nc : numer of communities
## k : number of covariates
## pClust: Probability of a ndoe belonging to a community
## N : Number of nodes
## pC : matrix of probability for binary assignment for each cluster 
NWSimBin <- function(nc, k, pC,N, pClust,B){
  C <- 0
  while(length(table(C)) < nc){
    C = sample(x = 1:nc,size = N,replace = TRUE, prob = pClust)
  }
  ## Create an empty network i.e. no cluster assignments or category assignments or edges
  net <- network(N, directed = FALSE, density= 0 )
  ## Assign clusters to the nodes 
  net %v% 'Cluster' <- C
  
  ## Based on the probability matrix pC assign indicates the binary assignment of covariates to a community
  binVal <- matrix(ncol =k, nrow =N, NA)
  # for(j in 1:k){
  #   print(pC[,j])
  #   for (i in 1:nc) {
  #     binVal[which(as.numeric(net %v% 'Cluster') == i), j]  <- rbinom(length(which(as.numeric(net %v% 'Cluster') == i)), 1, pC[i,j])
  #   }
  #   net %v% paste0("X",j) <- binVal[,j]
  # }
  
  for(i in 1:nc){
    for(j in 1:k){
      binVal[which(as.numeric(net %v% 'Cluster') == i), j] <- rbinom(length(which(as.numeric(net %v% 'Cluster') == i)), 1, pC[i,j])
    }
  }
  for(j in 1:k){
    net %v% paste0("X",j) <- binVal[,j]
  }
  
  ## Use the probability of connection values defined earlier for both cluster and category for fitting the data. 
  g.sim <- simulate(net ~ nodemix("Cluster", levels = TRUE, levels2 = TRUE),
                    nsim = 1,
                    coef = prob2logit(c(B)),
                    control=ergm::control.simulate( MCMC.burnin=10000, MCMC.interval=1000))
  return(g.sim)
  
}

#f_u : Community weight vector for node u
#Fvmat : Community weight matrix for nodes
#X_u: Covariate matrix
#Q_u: logistic probability matrix
#W: Logistic weight matrix
CmntyWtUpdt <- function(f_u, Fvmat,Fvnot, X_u, Q_u, W, alpha){
  
  ## Gradient function to update log likelihood of G
  ## First part of log likelihood of G
  a <- exp(-1*(f_u %*% t(Fvmat)))
  b <- a/(1-a)
  llG_1 <- t(Fvmat) %*% t(b)
  ## 2nd part of log likelihood of G
  llG_2 <- as.matrix(colSums(Fvnot))
  ## Total llG
  llG <- llG_1 -llG_2
  ## Updating the logistic regression weights
  ## Gradient function to update log likelihood for covariates
  ## adding intercept term
  Q_u <- t(1/(1+exp(-1*(W %*% as.matrix(c(1,f_u))))))
  llX <- t((X_u - Q_u) %*% W)
  
  ## Function to update the community weights vector using non negative matrix factorization
  f_u_new <- f_u + t((alpha *(llG+llX[1:nc])))
  f_u_new[f_u_new < 0] <- 0.0001
  
  return(f_u_new)
}


## W: Logistic weight matrix
## X: Covariate values
## Ftot: Community weight params
## alpha: tuning param
## lambda: 
LRParamUpdt <- function(W, X, Ftot, alpha, lambda){
  Ftotn <- cbind(1,Ftot)
  W_new <- matrix(nrow = dim(W)[1], ncol = dim(W)[2],0)
  for(i in 1:k){
    Q <- t(1/(1+exp(-1* W[i,] %*% t(Ftotn))))
    op <- data.frame(matrix(nrow = length(Q), ncol = dim(W)[2], 0 ))
    for(j in 1:(dim(W)[2])){
      op[,j] <- (X[,i] - Q) * Ftotn[,j]
    }
    
    W_new[i,] <- W[i, ] + alpha*(colSums(op) - lambda*sign(W[i,]))
  }
  
  #print(W_new)
  return(W_new)
}

findLL <- function(G, Ftot, W,X){
  E <- as_edgelist(G)
  F1 <- Ftot[E[,1],]
  F2 <- Ftot[E[,2],]
  S11 <- 0
  for(i in 1:dim(E)[1]){
    S11 <- S11 + log(1- exp(-1*sum(F1[i,] *F2[i,])))
  }
  
  A <- 1- (1 * as.matrix(as_adjacency_matrix(G)))
  E2<-  as_edgelist(graph_from_adjacency_matrix(A))
  F1 <- Ftot[E2[,1],]
  F2 <- Ftot[E2[,2],]
  S12 <- 0
  for(i in 1:dim(E2)[1]){
    S12 <- S12 + sum(F1[i,] * F2[i,])
  }
  S1 <- S11-S12
  S2 <- 0
  for(i in 1:gorder(G)){
    Q_uk <- 1/(1+exp(-1*rowSums(c(1, Ftot[i,]) * W)))#1/(1+exp(-1*c(1, Ftot[i,]) %*% t(W)))
    S2 <- S2 + sum((log(Q_uk) * X[i,]) + (log(1-Q_uk) * (1-X[i,])))
  }
  ll <- S1 + S2
  #print(paste0("Final log lik, ",ll))
  return(ll)
}

CESNA <- function(G, nc, k, N, alpha, lambda, thresh, nitermax, randomize =TRUE, orig){
  
  ## Setting initial values for lgistic weights
  W <- matrix(nrow = k, ncol = nc+1, sample(seq(0.0001,0.005,length.out =10000), k*(nc+1), replace = TRUE))
  
  ## Community weights
  Ftot <- matrix(nrow = N, ncol = nc,sample(seq(0.0001,0.005,length.out =10000), N*nc, replace = TRUE))
  Ftotold <- Ftot
  iter <- 0
  
  ## Get the covariate matrix
  X <- as.matrix(as.data.frame(vertex_attr(G))%>% 
                   dplyr::select(tail(names(.),k)))
  
  ## Updating all the node community weights
  ## Setting the new loglikelihood to 0 
  LLold <- -2000000
  LLnew <- -1000000
  tempop1 <- 0#list()
  LLG <- 0 #list()
  LLX <-0
  nodeid <-0
  
  #LLnew <- findLL(G,Ftot,W,X)
  arilst <- c()
  while (all(c(((LLnew - LLold) > thresh), (iter < nitermax))))  {
    #print(iter)
    Ftotold <- Ftot
    ## Updating the commuynity weight parameter
    s <- 1:N
    if(randomize == TRUE){
      s <- sample(1:N, size = N, replace = FALSE)
    }
    for (i in s) {
      f_u <- t(as.matrix(Ftot[i,]))
      ##The neighbours of this node
      neigh <- neighbors(G, i, mode = "all")
      Fvmat <- as.matrix(Ftot[neigh,])
      Fvnot <- as.matrix(Ftot[-neigh,])
      X_u <- X[i,]
      Ftot[i,] <- CmntyWtUpdt(f_u, Fvmat,Fvnot, X_u, Q_u, W, alpha)      
      tempop1 <- append(tempop1, list(Ftot[i,]))
      nodeid <- append(nodeid, i)
    }
    
    ## Updating logistic paramters
    W <-  LRParamUpdt(W, X, Ftot, alpha, lambda)
    
    ## Look for Communities based on the F matrix
    mem <- rep(NA, N)
    for(i in 1:N){
      mem[i] <- which.max(Ftot[i,])
    }
    arilst <- c(arilst, mclust::adjustedRandIndex(orig, mem))
    
    
    ## Update the log likelihood.
    LLold <- LLnew
    LLnew <- findLL(G,Ftot,W,X)
    iter <- iter+1
  }
  
  ## Updating the logistic weight parameters
  return(list(Ftotold, arilst))
}

```


## Checking communtiy detection function using predefined logistic paramters.

```{r}

## Creating simulation of the data
nc <- 3
k <- 3
N <- 100
pClust <- c(0.3,0.3,0.3)
#c(0.7,0,0,0,0.7,0,0,0,0.7)
pC <- matrix(nrow=nc, ncol =k,data = c(1,0,0,
                                       0,1,0,
                                       0,0,1))
B <- c(0.5,0.01,0.5,0.01,0.01,0.5)

## setting alpha value
alpha <- 0.001

## setting lambda value
lambda <- 0.001

## Setting threshold for log-likelihood difference
thresh <- 0.001
# Setting iterations if log likelihood is taking too long
nitermax <- 500
Nsim <- 20

G <- intergraph::asIgraph(NWSimBin(nc, k, pC, N, pClust, B))
ARIV <- rep(0,Nsim)
arilst <- list()
for(j in 1:Nsim){
  print(j)
  
  op <- CESNA(G, nc, k, N, alpha, lambda, thresh, nitermax, TRUE,c(V(G)$Cluster))
  
  Ffin <- op[[1]]
  arilst <- append(arilst, list(op[[2]]))
  ## Look for Communities based on the F matrix
  mem <- rep(NA, N)
  
  for(i in 1:N){
    mem[i] <- which.max(Ffin[i,])
  }
  Ffin <- as.data.frame(Ffin)
  Ffin$orig <- c(V(G)$Cluster)
  Ffin$cd <- mem
  ARIV[j] <- mclust::adjustedRandIndex(Ffin$orig, Ffin$cd)
  plot(G, vertex.color = mem,vertex.label = NA,vertex.size = 5)
}
ARIV_NewG <- ARIV

### Look for Communities based on the F matrix
plot(G, vertex.color = V(G)$Cluster,vertex.label = NA,vertex.size = 5)

Ffin <- as.data.frame(Ffin)
Ffin$orig <- c(V(G)$Cluster)
Ffin$cd <- mem
Ffin$x1 <- c(V(G)$X1)
Ffin$x2 <- c(V(G)$X2)
Ffin$x3 <- c(V(G)$X3)


mclust::adjustedRandIndex(Ffin$orig, Ffin$cd)

```


```{r}

p <- ggplot()

for(i in 1:Nsim){
  print(m <- length(arilst[[i]]))
  
  print(ggplot() + geom_line(aes(x = 1:m, y = arilst[[i]])))
}

```
```{r}
##plotting the ari values
printplots <- function(opf){
  #nc <-ncVal
  comp <-  data.frame( maxari = rep(0,dim(EG)[1]), llike =rep(0,dim(EG)[1]),
                       alpha =rep(0,dim(EG)[1]), alphaLL=rep(0,dim(EG)[1]),
                       nc =rep(0,dim(EG)[1]), MSE = rep(0,dim(EG)[1]))
  for(i in 1:dim(EG)[1]){
    #print(i)
    nc <- EG[i,4]
    comp$maxari[i] <- max(opf[[i]][[4]])
    comp$llike[i] <- opf[[i]][[6]][which.max(opf[[i]][[4]])]
    comp$alpha[i] <- EG[i,2]
    comp$alphaLL[i] <- EG[i,3]
    comp$nc[i] <- EG[i,4]
    # a <- ggplot()+
    #   geom_line(aes(x = 1:length(opf[[i]][[4]]), y = as.numeric(opf[[i]][[4]])))+
    #   ylab("ARI")+xlab("number of iterations")+scale_y_continuous(limits = c(0,1))+
    #   theme_minimal()
    # b <- ggplot()+
    #   geom_line(aes(x = 1:length(opf[[i]][[6]]), y = as.numeric(opf[[i]][[6]])))+
    #   ylab("log lik")+xlab("number of iterations")+
    #   theme_minimal()
    if(all(dim(opf[[i]][[9]])[1] > 0, !(is.null(opf[[i]][[9]])))){
      comp$MSE[i] <- min(opf[[i]][[9]])
      # c <-  as.data.frame(opf[[i]][[9]]) %>%
      #   mutate(x = 1:dim(opf[[i]][[9]])[1]) %>%
      #   pivot_longer(cols = !x ,names_to = "cov") %>% 
      #   ggplot()+
      #   geom_line(aes(x = x, y = value, color = cov))+
      #   ylab("mean sq error")+xlab("number of iterations")+
      #   theme(legend.position="bottom")
      # grid.arrange(a,b,c)
    }else if(all(dim(opf[[i]][[10]])[1] > 0, !(is.null(opf[[i]][[10]])))){
      # c <-  as.data.frame(opf[[i]][[10]]) %>%
      #   mutate(x = 1:dim(opf[[i]][[10]])[1]) %>%
      #   pivot_longer(cols = !x ,names_to = "binCov") %>% 
      #   ggplot()+
      #   geom_line(aes(x = x, y = value, color = binCov))+
      #   ylab("accuracy")+xlab("number of iterations")+ scale_y_continuous(limits = c(0,1))+
      #   theme(legend.position="bottom")
      # grid.arrange(a,b,c)
    }else{
     # grid.arrange(a,b)
    }
  }
  print(comp %>% 
          ggplot()+
          geom_point(aes(x = llike, y = maxari))+
          theme_minimal())
  
  print(comp %>% 
          ggplot()+
          geom_point(aes(x = MSE, y = maxari))+
          theme_minimal())
  
  t1 <- which.max(comp$maxari)
  print(paste0("The maximum ARI value is at this index ",t1))
  t2 <- which.max(comp$llike)
  print(paste0("The max LL is at this index ",t2))
  t3 <- which.min(comp$MSE)
  print(paste0("The min MSE is at this index ",t3))
  
  ## Find the overlapping communities.
  delta <- round(sqrt(-1*log(1-(1/N))),4)
#  t1 <- 130
#  for(t in c(t1,t2,t3)){
  for(t in c(t1,t2,t3)){
    #print(delta)
    memoverlap <- as.data.frame(matrix(0, ncol = EG[t,4], nrow = N ))
    for(i in 1:N){
      memoverlap[i,] <- as.numeric(opf[[t]][[1]][i,] > delta)
    }
    colnames(memoverlap) <- letters[1:EG[t,4]]
    memoverlap$id <- 1:N
    memoverlap <- memoverlap %>%
      pivot_longer(!id)
    memoverlap <- memoverlap[memoverlap$value == 1,]
    
    mem <- rep(NA, N)
    for(i in 1:N){
      mem[i] <- which.max(opf[[t]][[1]][i,])
    }
    if(!sim){
      lo <-  readRDS("35CityLocs.rds")
      igraphplots(G,mem,memoverlap,EG[t,4], t, lo,k+o)
      imputed <- data.frame(membership = mem, value = opf[[t]][[8]], 
                            cov = cov, covmem = origCov, 
                            naval = is.na(V(G)$covVal))
      print(imputed %>% ggplot()+
              geom_histogram(aes(x = covVal, fill = as.factor(naval)))+
              facet_wrap(~membership, ncol =1)+ggtitle("CESNA")+ theme_minimal())
      print(imputed %>% ggplot()+
              geom_histogram(aes(x = cov, fill = as.factor(naval)))+
              facet_wrap(~covmem, ncol =1)+ggtitle("Spectral Clustering") +theme_minimal())
      
    }else{
      igraphplots(G,mem,memoverlap,EG[t,4], t, NULL,k+o)
      
    }
  }
   print(comp %>%
  #filter(nc ==3) %>%
 ggplot()+
  geom_point(aes(x = MSE, y = maxari, color = as.factor(alpha) ) )+
  ylab("Adjusted Rand Index")+
  labs(color = "alpha")+
  scale_color_manual(values=c("firebrick3", "blue3", "springgreen3"))+
  theme(legend.position = "bottom", 
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        panel.background = element_rect(fill = "gray95",
                                colour = "white",
                                size = 0.5, linetype = "solid"))+
  facet_grid( nc ~ alphaLL))
  return(comp)
}

igraphplots <- function(G, mem, memoverlap, nc, t,lo = match.fun(layout_nicely), covnum=0){
  #nc <- ncVal
  grp <-  data.frame(group = letters[1:nc], cmnty = 1:nc)
  mem <- data.frame(cmnty = mem, id = 1:length(mem))
  members <- left_join(mem, grp)
  group_ids <- lapply(members %>% split(.$group), function(grp) { grp$id })
  group_color <- brewer.pal(length(group_ids), 'Set1')
  # the fill gets an additional alpha value for transparency:
  group_color_fill <- paste0(group_color, '20')
  
  # plot.igraph(G, vertex.label = NA, vertex.size = 5, vertex.color = orig, 
  #             edge.arrow.size= 0.1, edge.color = "grey28", layout = lo,
  #             mark.groups = group_ids,mark.col = group_color_fill, mark.border = group_color)
  plot.igraph(G, vertex.label = NA, vertex.size = 5, vertex.color = orig, 
              edge.arrow.size= 0.1, edge.color = "grey28", layout = lo)
  plot.igraph(G, vertex.label = NA, vertex.size = 5, vertex.color = "gray70",
              vertex.edge.color = "gray50",
              edge.arrow.size= 0.1, edge.color = "grey28", layout = lo)
 
  if(covnum > 0){
    plot.igraph(G, vertex.label = NA, vertex.size = 5, vertex.color = origCov,
                edge.arrow.size= 0.1, layout = lo, edge.color = "grey28")
  }
  
  plot.igraph(G, vertex.label = NA, vertex.size = 5, vertex.color = mem$cmnty,
              edge.arrow.size= 0.1, layout = lo, edge.color = "grey28", main = as.character(t))
  
  group_ids_ol <- lapply(memoverlap %>% split(.$name), function(grp) { grp$id })
  group_color_ol <- brewer.pal(length(group_ids_ol), 'Set1')
  group_color_fill_ol <- paste0(group_color, '20')
  plot.igraph(G, vertex.label = NA, vertex.size = 5, vertex.color =mem$cmnty, 
              edge.arrow.size= 0.1, edge.color = "grey28", layout = lo, 
              mark.groups = group_ids_ol,
              mark.col = group_color_fill_ol, mark.border = group_color_ol)
  
  
}

```

## Current run

```{r}
op <- printplots(opf)
```



## Undirected graph with covariates

```{r}
gbg <- readRDS("../FinalCESNAsim.rds")
opf <- gbg[[1]]
op  <- gbg[[2]]
EG  <- gbg[[3]]
G   <- gbg[[4]]
op <- printplots(opf) ## No excoriates only structure dependent. alpha =0.005


```


## Directed graphs with covariates
```{r}
gbg <- readRDS("../BigOutputFileDirected.rds")
opf <- gbg[[1]]
op  <- gbg[[2]]
EG  <- gbg[[3]]
G   <- gbg[[4]]
op  <- printplots(opf) ## No excoriates only structure dependent. alpha =0.005

```


## BigClam No covariates

```{r}
#saveRDS(list(opf,op,EG,G),"BigOutputFileBigClam.rds" )
gbg <- readRDS("BigOutputFileBigClam.rds")
opf <- gbg[[1]]
op  <- gbg[[2]]
EG  <- gbg[[3]]
G   <- gbg[[4]]
op  <- printplots(opf) ## No excoriates only structure dependent. alpha =0.005

```

```{r}
printplots(opf) ## no missing values each 3 binary covariates
## The alpha for updating W is set to 0.01 
```

```{r}
printplots(opf) ## no missing values each 3 binary covariates
## The alpha for updating W is set to 0.05 
```


```{r}
printplots(opf) ## no missing values each 3 binary covariates
## The alpha for updating W is set to 0.1 
```

```{r}
printplots(opf) ## 5 missing values each 3 binary covariates
## The alpha for updating W is set to 0.05 
```


```{r}
printplots(opf) ## 5 missing values each 3 binary covariates
## The alpha for updating W is set to 0.1
```


```{r}
printplots(opf) ## 5 missing values each 3 binary covariates
## The alpha for updating W is set to same alpha as community weight updates 0.001
```


```{r}
printplots(opf) ## real world wastewater data on movement network. wihtout continuous covariate
#alpha <- 0.001
```


```{r}
printplots(opf) ## real world wastewater data on movement network. No covariate
#alpha <- 0.002
```



```{r}
printplots(opf) ## real world wastewater data on movement network. W cov
#alpha <- 0.001
```



```{r}
N<- 100
library(gridExtra)
normalize <- function(x){
  return((x-min(x))/(max(x)-min(x)))
}

sumOrig <- data.frame(matrix(nrow = 0, ncol = 14))
sumFin <- data.frame(matrix(nrow = 0, ncol = 14))
fullDat <- data.frame(matrix(nrow=0, ncol = 15))
## plotting the values of the original F matrix
for(i in 1:Nsim){
  sumOrig <- rbind(sumOrig, c(apply(opf[[i]][[2]], 2, min), 
                              apply(opf[[i]][[2]], 2, max), 
                              apply(opf[[i]][[2]], 2, mean), 
                              apply(opf[[i]][[2]], 2, sd),
                              max(opf[[i]][[4]]),
                              i))
  sumFin <- rbind(sumFin, c(apply(opf[[i]][[1]], 2, min), 
                            apply(opf[[i]][[1]], 2, max), 
                            apply(opf[[i]][[1]], 2, mean), 
                            apply(opf[[i]][[1]], 2, sd),
                            max(opf[[i]][[4]]),
                            i))
  a <- data.frame(cbind(rbind(normalize(opf[[i]][[2]]), normalize(opf[[i]][[1]])), 
                        as.numeric(c(1:N, 1:N)),
                        rep(c("orig","final"), each = N),
                        c(V(G)$Cluster, V(G)$Cluster)))
  fullDat <- rbind(fullDat, cbind(a[a$X5 == "orig",], i))
  a <- a %>%
    pivot_longer(!c(X4, X5, X6)) %>%
    arrange(X6,as.numeric(X4),X5)
  a$X4 <- as.character(a$X4)
  maxV <- a %>%
    filter(X5 == "orig")%>%
    group_by(X6) %>%
    summarise(maxnode = max(as.numeric(X4)))
  lvl <- unique(a$X4)
  a$X4 <- factor(a$X4, levels = lvl)
  maxV$maxnode <- factor(maxV$maxnode, levels = lvl)
  a <- a %>%
    ggplot()+
    geom_point(aes(x = X4, y =as.numeric(value), color = X5))+
    geom_vline(xintercept = maxV$maxnode)+
    facet_wrap(~name, nrow = 3, scales = "free")+
    theme(axis.text.x = element_text(angle = 90),
          text = element_text(size = 9),
          strip.text.x = element_blank())
  
  b <- ggplot()+
    geom_line(aes(x = 1:length(opf[[i]][[4]]), y = opf[[i]][[4]]))+
    theme_minimal()
  
  grid.arrange(a,b)
}


colnames(sumOrig) <- c(paste0("min", c(1,2,3)), 
                       paste0("max", c(1,2,3)),
                       paste0("mean",c(1,2,3)),
                       paste0("sd", c(1,2,3)),
                       "MaxARI",
                       "sim")

colnames(sumFin) <- colnames(sumOrig)
sumOrig$type <- "orig"

sumFin$type <- "final"

sum <- rbind(sumOrig, sumFin)
#df <- sum %>%
#  pivot_longer(!c(MaxARI, sim, type))

sum %>% filter(type == "orig") %>%
  ggplot()+
  #geom_point(aes(x = sim, y = value, color = type))+
  geom_point(aes(x = sim, y = mean1, color = (MaxARI == 1)))+
  geom_point(aes(x = sim, y = mean1-sd1, color = (MaxARI == 1)))+
  geom_point(aes(x = sim, y = mean1+sd1, color = (MaxARI == 1)))+
  theme_minimal()
#facet_wrap(~name, scales= "free")

sum %>% filter(type == "orig") %>%
  ggplot()+
  #geom_point(aes(x = sim, y = value, color = type))+
  geom_point(aes(x = sim, y = mean2, color = (MaxARI == 1)))+
  geom_point(aes(x = sim, y = mean2-sd2, color = (MaxARI == 1)))+
  geom_point(aes(x = sim, y = mean2+sd2, color = (MaxARI == 1)))+
  theme_minimal()
sum %>% filter(type == "orig") %>%
  ggplot()+
  #geom_point(aes(x = sim, y = value, color = type))+
  geom_point(aes(x = sim, y = mean3, color = (MaxARI == 1)))+
  geom_point(aes(x = sim, y = mean3-sd3, color = (MaxARI == 1)))+
  geom_point(aes(x = sim, y = mean3+sd3, color = (MaxARI == 1)))+
  theme_minimal()

fullDat <- fullDat %>%
  group_by(i, X6) %>%
  summarise(mn1 = mean(as.numeric(X1)), mn2 = mean(as.numeric(X2)),mn3 = mean(as.numeric(X3)),
            sd1 = sd(as.numeric(X1)), sd2 = sd(as.numeric(X2)),sd3 = sd(as.numeric(X3)))

#fullDat$MaxARI <- rep(sumOrig$MaxARI, each =3)

# fullDat %>%
#   ggplot()+
#   geom_point(aes(x = i, y = mn3, color = (MaxARI == 1)))+
#     geom_point(aes(x = i, y = mn3-sd3, color = (MaxARI == 1)))+
#   geom_point(aes(x = i, y = mn3+sd3, color = (MaxARI == 1)))+
#   facet_wrap(~X6, nrow =3)+
#   theme_minimal()

## Doesnt look like there is any difference in the groupwise mean for different cluster means 

```

```{r}

ImputeVal <- cbind( opf[[1]][[8]], data.frame(vertex_attr(G)), data.frame(opf[[1]][[1]]))
opf[[1]][[7]]
opfSim[[1]][[7]]
```



```{r}
wfin <- data.frame(matrix(nrow = 0, ncol = 7))
maxARI <- c()
for(i in 1:Nsim){
  wfin <- rbind(wfin,rbind(cbind(opf[[i]][[3]], "orig",i,c("c1","c2","c3")),
                           cbind(opf[[i]][[5]], "final", i,c("c1","c2","c3"))))
  maxARI <- c(maxARI, floor(max(opf[[i]][[4]])) == 1)
}

colnames(wfin) <- c(paste0("LRcmtyWts", c(1,2,3,4)), "type", "sim","grp")
wfin$ARI <- rep(maxARI, each=6)
wfin <- wfin %>%
  pivot_longer(!c(type, sim, grp, ARI))
wfin %>%
  ggplot()+
  geom_point(aes(x = as.numeric(sim),y = as.numeric(value), color = type ))+
  geom_point(data = wfin[wfin$ARI==FALSE, ],
             aes(x = as.numeric(sim),y = as.numeric(value)), 
             shape = 1, color = "blue4")+
  facet_grid(vars(name),vars(grp))
#facet_wrap(~name, scales= "free")

#for(i in 1:Nsim){
#  df <-  rbind(df, cbind(apply(opf[[i]][[2]], 1, var), i))
#}


```


```{r}
## Looking at variances between the oroginal values of F. and W alone
df <- data.frame(matrix(nrow = 0, ncol = 2))
for(i in 1: Nsim){
  df <- rbind(df, cbind(opf[[i]][[2]], i))
}

df %>%
  pivot_longer(!i) %>%
  group_by(i, name) %>%
  summarise(varV =  var(value), 
            meanV = mean(value))%>%
  ggplot()+
  geom_line(aes(x = i, y = varV, color = name))+
  geom_point(aes(x = i, y = meanV))

```


```{r}
df <- data.frame(matrix(nrow = 0, ncol = 3))
initV <- c()
finV <- c()
ariLgcl <- c()
for(i in 1:Nsim){
  df <- rbind(df, cbind(opf[[i]][[6]], i, (opf[[i]][[4]][length(opf[[i]][[4]])]) == 1 ))
  initV <- c(initV, opf[[i]][[6]][1])
  finV <- c(finV, opf[[i]][[6]][length(opf[[i]][[6]])])
  ariLgcl <- c(ariLgcl, (opf[[i]][[4]][length(opf[[i]][[4]])]) == 1)
}
ariLgcl <- !ariLgcl
df %>% 
  group_by(i) %>%
  mutate(idx = row_number(i)) %>%
  ggplot() +
  geom_line(aes(x = idx, y = V1, group = factor(i), color = factor(V3)), alpha =0.5)+
  scale_color_manual(values= c( "navyblue","gray50"))

ggplot()+
  geom_point(aes(x = 1:Nsim, y = initV), color = "green4")+
  geom_point(aes(x = 1:Nsim, y = finV) , color = "blue4")+
  geom_point(aes(x = (1:Nsim)[ariLgcl], y = initV[ariLgcl]), color = "pink")+
  geom_point(aes(x = (1:Nsim)[ariLgcl], y = finV[ariLgcl]) , color = "pink")

```



```{r}

## W: Logistic weight matrix
## X: Covariate values
## Ftot: Community weight params
## alpha: tuning param
## lambda: 
SlowLRParamUpdt <- function(W, X, Ftot, alpha, lambda){
  W_new <- matrix(nrow = dim(W)[1], ncol = dim(W)[2], 0)
  Ftot <- cbind(1,Ftot)
  Q_u <-  t(W %*% t(Ftot))
  for(i in 1:dim(W)[1]){ ## param
    for(j in 1:dim(W)[2]){ ## community
      p <- 0
      for (k in dim(Ftot)[1]) { ## node
        
        p <- p+ (X[k,i] - Q_u[k,i])*Ftot[k,j]
      }
      W_new[i,j] <- W[i,j] +alpha*(p - lambda*sign(W[i,j]))
    }
  }
  
  return(W_new)
}

SlowCmntyWtUpdt <- function(f_u, Fvmat,Fvnot, X_u, Q_u, W, alpha){
  f_u_new <- rep(0,dim(f_u)[2])
  llg <- rep(0,dim(f_u)[2])
  ## first part of cmnty update
  for(j in 1:dim(f_u)[2]){
    llg1 <- 0
    llg2 <- 0
    for(i in 1:dim(Fvmat)[1]){
      a <- exp(-1*f_u %*% Fvmat[i,])
      b <- a/1-a
      llg1 <- llg1 + Fvmat[i,j]*b
    }
    for(i in 1:dim(Fvnot)[1]){
      llg2 <- llg2 + Fvnot[i,j]
    }
    llg[j] <- llg1-llg2
  }
  
  ## 2nd part of cmnty update
  Q_u <- rep(0,dim(W)[1])
  f_un <- cbind(1,f_u)
  for(j in 1:dim(W)[1]){
    c <- 0
    for(i in 1:dim(W)[2]){
      c <- c + W[j,i]* f_un[i]
    }
    Q_u[j] <- 1/(1+exp(-1*c))
  }
  
  llx <- rep(0,dim(f_u)[2])
  for( i in 1:dim(f_u)[2]){
    m <- 0
    for(j in 1:dim(W)[1]){
      m <- m + ((X_u[j]- Q_u[j]) * W[j,i+1])
    }
    llx[i] <- m
  }
  
  f_u_new <- f_u + alpha*(llg+llx)
  f_u_new[f_u_new < 0] <- 0
  
  return(f_u_new)
}
```

